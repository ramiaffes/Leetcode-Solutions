
map< int, int> parent;
void make_set( int  v) {
    parent[v] = v;
}
 
int find_set(int v) {
    if (v == parent[v])
        return v;
    return(find_set(parent[v]));
}
 
void union_sets(int a, int b) {
    a = find_set(a);
    b = find_set(b);
    if (a != b){
        parent[b] = a;
    }
 
}
class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        parent.clear();
        for(int i=0;i<graph.size();i++){
            make_set(i);
        }
    for(int i=0;i<(graph.size()-1);i++){
        for(int j=i+1;j<graph.size();j++){
            if(graph[i][j]==1)
            union_sets(i,j);
        }
    }
    map<int,int>hashing;
    sort(initial.begin(),initial.end());
    for(int i=0;i<initial.size();i++){
        hashing[find_set(initial[i])]++;
    }
        int ans=1e9;
        map<int,bool>vis;
        map<int,int>hashing10;
    for(int i=0;i<initial.size();i++){
        if(hashing[find_set(initial[i])]==1){vis[find_set(initial[i])]=1;}
        else ans=min(ans,initial[i]);
    }
    int ans11=0;
        map<int,bool>vis2;
    for(int i=0;i<graph.size();i++){
        if(vis[find_set(i)]){
        hashing10[find_set(i)]++;
        ans11=max(ans11,hashing10[find_set(i)]);}
    }
        
    for(auto v:hashing10){
        if(v.second==ans11){
            vis2[v.first]=1;
        }
    }
    sort(initial.begin(),initial.end());
    for(int i=0;i<initial.size();i++){
        if(vis2[find_set(initial[i])])return initial[i];
    }
    
    
    return ans;
    
    
        
    
    }
};